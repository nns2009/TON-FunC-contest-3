{-
	In TON there is a limit on the size of the external message which can be sent equal to 64 kB. Sometimes it is necessary to send a larger message; it requires the onchain construction of one message from multiple smaller parts. Your task is to create such construction contract.
	In particular, a contestant needs to develop a FunC contract with two features:
		a) it has get_method "decomposite" for decomposition of large cell to parts: it accepts 1 cell (number_of_bits<1000000, number_of_cells<4000 , depth<256) and 1 address and returns tuple of cells (each of which has less than 1000 distinct cells and 40000 bits total), those cells will be transformed to slice and sent as internal message body to the contract.
		b) recv_internal should handle those internal messages from get-method described above and upon receiving last one, send initial large cell to the address (coins amount 0, mode 0). For simplicity, it is guaranteed that messages will be sent exactly in the order in which they were in decomposite output and no other messages will be sent in between.
	Note, that initial state of contract storage will be empty cell: cell with zero bits and refs.
-}


int tuple_len(tuple t) asm "TLEN";
(tuple, int) ~tuple_pop(tuple t) asm "TPOP";

(cell, int) udict_get_ref?fixed(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF" "NULLSWAPIFNOT";


const Cell_Max_Bits = 1023;
const Cell_Max_Refs = 4;


const int group_max_cells = 30; ;; 30 * 1023 = 30690 < 40000 with some extra room just in case


const int groups_dict_len = 10; ;; Should store up to 255 entries, but let's be safe
const int command_len = 3;
const int bitslen_len = 10; ;; bitslen from 0 to 1023 (inclusive) - covers all cases

const int create_builder_code = 1;
const int push_ref_code = 2;
const int push_bits_code = 3;
const int end_builder_code = 4;
;; const int command_send_code = 5;


(int, cell) load_data() {
	slice cs = get_data().begin_parse();
	if (cs.slice_data_empty?()) {
		return (0, new_dict());
	}

	int group_count = cs~load_uint(16);
	cell groups = cs~load_dict();
	return (group_count, groups);
}

() save_data(int group_count, cell groups) impure {
	set_data(begin_cell()
		.store_uint(group_count, 16)
		.store_dict(groups)
		.end_cell()
	);
}





(slice, int) ~read_uint(slice cs, int len) {
	if (cs.slice_bits() < len) {
		if (cs.slice_refs_empty?()) {
			return (cs, -1);
		}
		cs = cs.preload_ref().begin_parse();
	}

	if (cs.slice_bits() >= len) {
		int res = cs~load_uint(len);
		return (cs, res);
	}

	;; Line below should actually never happen
	;; If 'cs' started with not enough bits,
	;; but was able to load a ref,
	;; than that ref should have been there for a reason
	return (cs, -1);
}
;; No <function templating> in FunC => copy-paste :(
(slice, slice) ~read_slice(slice cs, int len) {
	if (cs.slice_bits() < len) {
		;; No extra checks because reading "slice" is mandatory
		cs = cs.preload_ref().begin_parse();
	}
	slice res = cs~load_slice(len);
	return (cs, res);
}

(slice, int) ~read_op_code(slice cs) {
	return ~read_uint(cs, command_len);
}
(slice, slice) ~read_bits(slice cs) {
	int bitslen = cs~read_uint(bitslen_len);
	return ~read_slice(cs, bitslen);
}


() ex_create_builder() impure { }
() ex_push_ref() impure { }
() ex_push_bits(slice bits) impure { }
() ex_end_builder() impure { }


() process_group(cell group) {
	slice cs = group.begin_parse();

	do {
		int op_code = cs~read_op_code();
		if (op code == create_builder_code) { ex_create_builder(); }
		elseif (op_code == push_ref_code) { ex_push_ref(); }
		elseif (op_code == push_bits_code) {
			slice bits = cs~read_bits();
			ex_push_bits(bits);
		}
		elseif (op_code == end_builder_code) { ex_end_builder(); }
	} until (op_code < 0);
}

;; testable
() recv_internal (slice body) {
	int finish = body~load_int(1);

	slice destination = null();
	if (finish) {
		destination = body~load_msg_addr();
	}

	(int group_count, cell groups) = load_data();
	groups~udict_set_ref(groups_dict_len, group_count, begin_cell().store_slice(body).end_cell());
	group_count += 1;

	if (finish) {
		int i = 0;
		while (i < group_count) {
			(cell group, int f) = groups~udict_get_ref?fixed(groups_dict_len, i);
			;; f has to be "true", because we are iterating through "known" indexes
			process_group(group);

			i += 1;
		}
	}

	save_data(group_count, groups);
}




global tuple bs;
global tuple out_cells;


;; 'bs' length has to be >= 1 !
() collapse_builders() impure {
	builder inner = bs~tpop();

	cell c = inner.end_cell();
	repeat (bs.tuple_len()) {
		builder b = bs~tpop();
		c = b.store_ref(c).end_cell();
	}

	out_cells~tpush(c);
}
() collapse_remaining_builders() impure {
	if (bs.tuple_len() >= 1) {
		collapse_builders();
	}
}
() maybe_collapse_builders() impure {
	if (bs.tuple_len() >= group_max_cells) {
		collapse_builders();
	}
}


() write_uint(int v, int len) impure {
	builder b = bs~tuple_pop();
	if (b.builder_bits() + len > Cell_Max_Bits) {
		bs~tpush(b);
		b = begin_cell();
		maybe_collapse_builders();
	}
	b~store_uint(v, len);
	bs~tpush(b);
}
() write_slice(slice bits) impure {
	builder b = bs~tuple_pop();
	if (b.builder_bits() + bits.slice_bits() > Cell_Max_Bits) {
		bs~tpush(b);
		b = begin_cell();
		maybe_collapse_builders();
	}
	b~store_slice(bits);
	bs~tpush(b);
}


() write_op_code(int code) impure {
	write_uint(code, command_len);
}
() write_bits(slice bits) impure {
	write_uint(bits.slice_bits(), bitslen_len);
	write_slice(bits);
}

() create_builder() impure {
	write_op_code(create_builder_code);
}
() push_ref() impure {
	write_op_code(push_ref_code);
}
() push_bits(slice bits) impure {
	write_op_code(push_bits_code);
	write_bits(bits);
}
() end_builder() impure {
	write_op_code(end_builder_code);
}
;; () command_send(slice destination) impure {
;; 	write_op_code(command_send_code);
;; 	write_bits(destination);
;; }



() dfs(cell c) {
	slice cs = c.begin_parse();

	create_builder();
	;; int child_count = cs.slice_refs();
	while (~ cs.slice_refs_empty()) {
		cell child = cs~load_ref();
		dfs(child);
		push_ref();
	}

	;; repeat(child_count) {
	;; 	push_ref();
	;; }

	push_bits(cs);
	end_builder();
}

;; testable
tuple decomposite (cell big_cell, slice destination_address) method_id {
	bs = [begin_cell()];
	out_cells = [];
	dfs(big_cell);
	collapse_remaining_builders();
	;; command_send(destination_address);
}
